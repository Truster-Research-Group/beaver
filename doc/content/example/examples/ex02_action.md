# Step 1 - First steps

Let's get started with a minimal input file.

!listing examples/ex02_action/ex02.i

## Input file

### `GlobalParams`

In the `[GlobalParams]` we set a default value for the `temp`
parameters. That way we do not have to specify it explicitly in the multiple
blocks below that all need this parameter set.

### `Mesh`

We create a simple regular orthogonal mesh block using the
[`GeneratedMeshGenerator`](GeneratedMeshGenerator.md). All subblocks under
`[Mesh]` are the so called [*MeshGenerators*](meshgenerators/MeshGenerator.md).
They can be chained together and MOOSE provides a multitude of generators to
create and modify meshes. Later on we will see how to create a second block and
combine it into a two block mesh. A commonly used MeshGenerator is the
[`FileMeshGenerator`](FileMeshGenerator.md), it is used to load a mesh file
generated by third party software like Cubit of Gmsh (or sometimes even meshes
generated by MOOSE). MOOSE provides a shorthand for the `FileMeshGenerator`
through the [!param](/Mesh/FileMesh/file) parameter inside `[Mesh]`, e.g.

```
[Mesh]
  file = pressure_vessel.e
[]
```

MOOSE supports a [variety of mesh file formats](FileMeshGenerator.md); most
commonly used is the Exodus II format.

### Beaver HeatDiffusion `Master` Action

The third top level block has a path with three components in the title. You can
think of the MOOSE input file block structure like a directory.
[The `Master` action](Modules/TensorMechanics/Master/index.md)
is nested under `Modules` and `TensorMechanics`. A MOOSE Action is a convenience
object that can setup multiple aspects of a simulation for the user, resulting
in a more compact syntax. Actions can also enforce consistency in the simulation
definition. In this simple example the action will create the displacement
variables (as specified by the `GlobalParams/displacements` parameter). The
action will automatically determine if second order shape functions are needed,
based on the order of the mesh in the simulation (this works with any kind of
mesh, whether it is generated by MOOSE or read in from a file).

Furthermore the appropriate *strain calculator* will be added for the chosen
coordinate system (axisymmetric, spherical, Cartesian).

Check the [master action documentation](Modules/TensorMechanics/Master/index.md)
for a full run-down of all objects it creates.

### `Materials`

The two subblocks under [`[Materials]`](Materials/index.md) define an
[isotropic elasticity tensor](ComputeIsotropicElasticityTensor.md) and a
[linear elastic stress calculator](ComputeLinearElasticStress.md). Neither
object is block restricted (using the `block` parameter), so they apply to the
entire simulation domain.

### `Executioner`

In the [`[Executioner]`](Executioner/index.md) block all parameters relevant to the solution of the current
problem are set. [`type = Transient`](Transient.md) selects a time-dependent simulation (as
opposed to [`type = Steady`](Steady.md)). We chose to run for five simulation steps; with a
timestep of `1`.

### `Outputs`

We use the `exodus = true` shorthand to setup an output object of type `Exodus` to write
an Exodus II mesh and solution file to the disk. You can visualize these outputs using
[Paraview](https://www.paraview.org).

# Step 3 - Subdomains and subdomain-specific properties

In this step we'll be setting up two subdomains (regions of our sample) with
differing material properties.

!listing modules/tensor_mechanics/tutorials/introduction/mech_step03.i

## Input file

### `Mesh`

Note that we refine the mesh a bit to better capture the discontinuity we're
introducing below.

The `block1` and `block2` subblocks are part of a chain of mesh generators,
linked by their `input` parameters. Each of the
[`SubdomainBoundingBoxGenerator`](SubdomainBoundingBoxGenerator.md) adds a
subdomain definition to the current mesh. Here we define two subdomains, one for
the left half of the domain and one for the right.

### `Materials`

We now define two elasticity tensors in this problem, one on the left half
(`block = 1`) and on on the right half (`block = 2`), referring to the subdomain
IDs we assigned using the mesh generators above.

Note how the stiffness of the right hand side is only half that of the left hand side.

### `Executioner`

We make a few changes in the Executioner block here, and you should try playing with some of the settings later on.

- We select NEWTON as our [!param](/Executioner/Transient/solve_type). This is a good (fast) option whenever we have a complete Jacobian for the system. It should give us 1-2 linear iterations for every non-linear iteration. Note that for NEWTON solves MOOSE automatically sets up an [`SMP`](SingleMatrixPreconditioner.md) with the [!param](/Preconditioning/SMP/full) option set to `true` (this can be disabled by setting [!param](/Executioner/auto_preconditioning) to `false`).
- We use LU decomposition to solve the linear problem, this preconditioner is very effective on a small problem like this. (For a more scalable preconditioner for large problems take a look at [HYPRE](application_development/hypre.md optional=true).)

## Questions

### Visualizing strain

So far we've only looked at the deformation of the mesh. MOOSE can visualize a
host of mechanical quantities, and the master action makes this particularly
easy.

> Try and add output for the vonMises stress in the simulation domain. Take a
> look at the
> [!param](/Modules/TensorMechanics/Master/TensorMechanicsAction/generate_output)
> parameter...
